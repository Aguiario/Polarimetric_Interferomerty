import sympy as sp
import matplotlib.pyplot as plt
import cv2
import numpy as np


def symbolic_intensity(values=None):
    """
    Calculates the intensity pattern resulting from the interaction of polarized light
    with a birefringent material, modeled using Jones matrices and phase modulation.

    Parameters:
    -----------
    values : dict, optional
        A dictionary containing specific numerical values for the symbolic variables.
        If provided, the resulting intensity will be evaluated numerically.

    Returns:
    --------
    I : sympy expression or numerical value
        The calculated intensity as a symbolic expression or evaluated result
        if `values` is provided.
    """

    # Define symbolic variables for phase angles, spatial modulation, and amplitudes
    alpha, chi, mu, k, x, phi_is, phi_r = sp.symbols('alpha chi mu k x phi_is phi_r', real=True)
    A_isx, A_isy, A_rx, A_ry = sp.symbols('A_isx A_isy A_rx A_ry', real=True)

    # Define the reference electric field vector A_r
    E_r = sp.Matrix([[A_rx], [A_ry * sp.exp(1j * phi_r)]])

    # Waveplate (birefringent) matrix coefficients (Jones formalism)
    S_xx = sp.cos(alpha)**2 + sp.exp(-1j * chi) * sp.sin(alpha)**2
    S_xy = (1 - sp.exp(-1j * chi)) * sp.cos(alpha) * sp.sin(alpha)
    S_yx = S_xy
    S_yy = sp.sin(alpha)**2 + sp.exp(-1j * chi) * sp.cos(alpha)**2

    # Transformation of the input electric field vector E_is through the waveplate
    E_sx = S_xx * A_isx + S_xy * A_isy * sp.exp(1j * phi_is)
    E_sy = S_yx * A_isx + S_yy * A_isy * sp.exp(1j * phi_is)
    E_s = sp.Matrix([[E_sx], [E_sy]])

    # Intensity calculation components
    # Background 'b' is the sum of the squared norms (amplitudes) of the reference and sample vectors
    b = E_r.norm()**2 + E_s.norm()**2
    
    # Modulation 'm' is the magnitude of the dot product between the reference and transformed sample vectors
    m = sp.Abs(E_r.dot(E_s))

    # Calculation of the relative phase shift (vartheta)
    numerator = -sp.Abs(E_r[1, 0]) * sp.Abs(E_s[1]) * sp.sin(sp.arg(E_r[1, 0]) - sp.arg(E_s[1]))
    denominator = sp.Abs(E_r[0, 0]) * sp.Abs(E_s[0]) + sp.Abs(E_r[1, 0]) * sp.Abs(E_s[1]) * sp.cos(sp.arg(E_r[1, 0]) - sp.arg(E_s[1]))
    vartheta = sp.atan(numerator / denominator)

    # Phase modulation incorporating spatial modulation (kx) and global phase shift (mu)
    theta = (mu + k * x - vartheta)
    cos_term = sp.cos(theta)

    # Final intensity expression combining all calculated terms
    I = b + m * cos_term

    # Substitute numerical values if provided
    if values:
        I = I.subs(values).evalf()

    return I

def numeric_intensity(E_r, E_s, mu=0, n=1, plot=False):
    """
    Computes the numerical intensity distribution for an interferogram 
    generated by two electric field vectors E_r and E_s.

    Parameters:
    - E_r, E_s: Complex-valued electric field vectors.
    - mu: Phase offset (default is 0).
    - n: Number of phase steps or modulation factor (default is 1).
    - plot: Boolean to indicate if the resulting interferogram should be plotted (default is False).

    Returns:
    - info: List containing [b, m, vartheta, theta, cos_term]
      - b: Baseline intensity
      - m: Modulated intensity amplitude
      - vartheta: Relative phase shift between the fields
      - theta: Phase modulation term
      - cos_term: Cosine modulation term
    """

    # Wavelength of the light source (in meters)
    lambda_ = 532e-9  

    # Wave number (k = 2π/λ)
    k = 2 * np.pi / lambda_  

    # Image resolution (pixel dimensions)
    x_size = 1000  # Number of pixels in the x-axis
    y_size = 500   # Number of pixels in the y-axis

    # Conversion scales from pixels to meters
    x_scale = lambda_ / x_size  # Pixel size in meters along x-axis
    y_scale = lambda_ / y_size  # Pixel size in meters along y-axis

    # Create physical coordinate grids
    x_pixels = np.arange(x_size)  # X pixel indices
    y_pixels = np.arange(y_size)  # Y pixel indices
    X, Y = np.meshgrid(x_pixels, y_pixels)  # 2D coordinate grid
    X_meters = X * x_scale  # X coordinates in meters
    Y_meters = Y * y_scale  # Y coordinates in meters

    # Generate combined spatial coordinate for phase modulation
    x = X_meters + Y_meters

    # Intensity component calculations
    b = np.linalg.norm(E_r)**2 + np.linalg.norm(E_s)**2  # Baseline intensity
    m = np.abs(np.vdot(E_r, E_s))  # Modulated intensity amplitude

    # Compute the relative phase (vartheta)
    numerator = -np.abs(E_r[1]) * np.abs(E_s[1]) * np.sin(np.angle(E_r[1]) - np.angle(E_s[1]))
    denominator = (np.abs(E_r[0]) * np.abs(E_s[0]) +
                   np.abs(E_r[1]) * np.abs(E_s[1]) * np.cos(np.angle(E_r[1]) - np.angle(E_s[1])))
    vartheta = np.arctan(numerator / denominator)[0]

    # Phase modulation term
    theta = (n / 2) * (mu + k * x - vartheta)

    # Cosine term for interference pattern
    cos_term = np.cos(theta)

    # Final intensity calculation
    I = b + m * cos_term

    # Information array for reference
    info = [b, m, vartheta, theta, cos_term]

    # Optional plotting of the interferogram
    if plot:
        # Normalize the intensity to a range between 0 and 1
        I_norm = (I - I.min()) / (I.max() - I.min())

        # Apply Gaussian blur to smooth the fringe pattern
        I_blurred = cv2.GaussianBlur(I_norm, (5, 5), 0)

        # Display the interferogram
        plt.figure(figsize=(8, 6))
        extent = [X_meters.min(), X_meters.max(), Y_meters.min(), Y_meters.max()]
        plt.imshow(I_blurred, cmap='gray', aspect='auto', extent=extent)
        plt.xlabel("X (m)")
        plt.ylabel("Y (m)")
        plt.title("Interferogram")
        plt.colorbar(label="Intensity")
        plt.show()

    return info

def jones_matrix(delta, alpha):
    """
    Computes the Jones matrix for a birefringent optical element.

    Parameters:
    - delta : float
        The phase retardation introduced by the birefringent material (in radians).
        This phase shift is the optical path difference between the fast and slow
        axes of the birefringent material.
    
    - alpha : float
        The orientation angle (in radians) of the fast axis with respect to the
        reference axis (horizontal axis in the standard Jones formalism).

    Returns:
    - np.ndarray
        A 2x2 complex-valued numpy array representing the Jones matrix.
        This matrix describes the effect of the birefringent element on the 
        electric field's polarization state.
    """

    # Compute the individual elements of the Jones matrix
    # Diagonal element [0,0] — Describes the effect on the horizontal polarization component
    m_11 = np.cos(alpha) ** 2 + np.exp(-1j * delta) * np.sin(alpha) ** 2
    
    # Off-diagonal elements [0,1] and [1,0] — Represent the coupling between
    # horizontal and vertical polarization components
    m_12 = m_21 = (1 - np.exp(-1j * delta)) * np.cos(alpha) * np.sin(alpha)

    # Diagonal element [1,1] — Describes the effect on the vertical polarization component
    m_22 = np.sin(alpha) ** 2 + np.exp(-1j * delta) * np.cos(alpha) ** 2

    # Return the Jones matrix as a 2x2 complex-valued numpy array
    return np.array([[m_11, m_12], [m_21, m_22]], dtype=np.complex128)

def PSG(alpha_1, alpha_2):
    """
    Generates a Polarization State Generator (PSG) matrix using a Half-Wave Plate (HWP)
    and a Quarter-Wave Plate (QWP).

    Parameters:
    - alpha_1 : float
        The orientation angle (in radians) of the fast axis of the Half-Wave Plate (HWP)
        with respect to the reference axis.
    
    - alpha_2 : float
        The orientation angle (in radians) of the fast axis of the Quarter-Wave Plate (QWP)
        with respect to the reference axis.

    Returns:
    - np.ndarray
        A 2x2 complex-valued numpy array representing the resulting PSG matrix,
        which describes the combined effect of the QWP and HWP on the polarization state.
    """

    # Generate the Jones matrix for the Half-Wave Plate (HWP)
    # A HWP introduces a π phase retardation (180°) between its fast and slow axes
    HWP = jones_matrix(np.pi, alpha_1)

    # Generate the Jones matrix for the Quarter-Wave Plate (QWP)
    # A QWP introduces a π/2 phase retardation (90°) between its fast and slow axes
    QWP = jones_matrix(np.pi / 2, alpha_2)

    # Return the resulting matrix for the combined PSG system
    # The QWP follows the HWP in the optical path, so the matrices are multiplied in this order
    return QWP @ HWP



def field_notation(E, p=False):
    """
    Converts an electric field vector into field notation, extracting amplitude 
    and phase information for both polarization components.

    Parameters:
    - E : np.ndarray
        A 2x1 complex-valued array representing the electric field vector.
        E[0, 0] corresponds to the x-polarization component.
        E[1, 0] corresponds to the y-polarization component.

    - p : bool, optional (default = False)
        If True, prints the amplitude of both components and the relative phase
        difference in terms of π.

    Returns:
    - np.ndarray
        A 2x1 complex-valued array in field notation form:
        [[E_x], [E_y * exp(i * delta_phi)]]
        Where:
        - E_x and E_y are the magnitudes (amplitudes) of the field components.
        - delta_phi is the phase difference between the y and x components.
    """

    # Extract the amplitude (magnitude) and phase of the x-component
    E_x = np.round(np.abs(E[0, 0]), 5)    # Magnitude of E_x
    phi_x = np.round(np.angle(E[0, 0]), 5) # Phase of E_x

    # Extract the amplitude (magnitude) and phase of the y-component
    E_y = np.round(np.abs(E[1, 0]), 5)    # Magnitude of E_y
    phi_y = np.round(np.angle(E[1, 0]), 5) # Phase of E_y

    # Compute the relative phase difference (delta_phi)
    delta_phi = np.round(phi_y - phi_x, 5)

    # If the x-component is zero, set delta_phi to zero (prevents undefined phase difference)
    if E_x == 0 or E_y == 0:
        delta_phi = 0

    # Print values if 'p' is True
    if p:
        print(E_x)                        # Prints x-component amplitude
        print(E_y)                        # Prints y-component amplitude
        print(f"{np.round(delta_phi / np.pi, 5)}π")    # Prints phase difference in terms of π
        print()                           # Prints newline for readability

    # Return the field notation in the desired format
    return np.array([[E_x], [E_y * np.exp(1j * delta_phi)]])


