import sympy as sp
import matplotlib.pyplot as plt
import cv2
import numpy as np
import numpy as np
from scipy.optimize import minimize
from scipy.fft import fft, fftfreq
from scipy.interpolate import interp1d
import os
import imageio
from scipy.linalg import eig

def symbolic_intensity(values=None):
    """
    Calculates the intensity pattern resulting from the interaction of polarized light
    with a birefringent material, modeled using Jones matrices and phase modulation.

    Parameters:
    -----------
    values : dict, optional
        A dictionary containing specific numerical values for the symbolic variables.
        If provided, the resulting intensity will be evaluated numerically.

    Returns:
    --------
    I : sympy expression or numerical value
        The calculated intensity as a symbolic expression or evaluated result
        if `values` is provided.
    """

    # Define symbolic variables for phase angles, spatial modulation, and amplitudes
    alpha, chi, mu, k, x, phi_is, phi_r = sp.symbols('alpha chi mu k x phi_is phi_r', real=True)
    A_isx, A_isy, A_rx, A_ry = sp.symbols('A_isx A_isy A_rx A_ry', real=True)

    # Define the reference electric field vector A_r
    E_r = sp.Matrix([[A_rx], [A_ry * sp.exp(1j * phi_r)]])

    # Waveplate (birefringent) matrix coefficients (Jones formalism)
    S_xx = sp.cos(alpha)**2 + sp.exp(-1j * chi) * sp.sin(alpha)**2
    S_xy = (1 - sp.exp(-1j * chi)) * sp.cos(alpha) * sp.sin(alpha)
    S_yx = S_xy
    S_yy = sp.sin(alpha)**2 + sp.exp(-1j * chi) * sp.cos(alpha)**2

    # Transformation of the input electric field vector E_is through the waveplate
    E_sx = S_xx * A_isx + S_xy * A_isy * sp.exp(1j * phi_is)
    E_sy = S_yx * A_isx + S_yy * A_isy * sp.exp(1j * phi_is)
    E_s = sp.Matrix([[E_sx], [E_sy]])

    # Intensity calculation components
    # Background 'b' is the sum of the squared norms (amplitudes) of the reference and sample vectors
    b = E_r.norm()**2 + E_s.norm()**2
    
    # Modulation 'm' is the magnitude of the dot product between the reference and transformed sample vectors
    m = sp.Abs(E_r.dot(E_s))

    # Calculation of the relative phase shift (vartheta)
    numerator = -sp.Abs(E_r[1, 0]) * sp.Abs(E_s[1]) * sp.sin(sp.arg(E_r[1, 0]) - sp.arg(E_s[1]))
    denominator = sp.Abs(E_r[0, 0]) * sp.Abs(E_s[0]) + sp.Abs(E_r[1, 0]) * sp.Abs(E_s[1]) * sp.cos(sp.arg(E_r[1, 0]) - sp.arg(E_s[1]))
    vartheta = sp.atan(numerator / denominator)

    # Phase modulation incorporating spatial modulation (kx) and global phase shift (mu)
    theta = (mu + k * x - vartheta)
    cos_term = sp.cos(theta)

    # Final intensity expression combining all calculated terms
    I = b + m * cos_term

    # Substitute numerical values if provided
    if values:
        I = I.subs(values).evalf()

    return I

def numeric_intensity(E_r, E_s, mu=0, x_size = 1000, y_size = 500, n=1, plot=False):
    """
    Computes the numerical intensity distribution for an interferogram 
    generated by two electric field vectors E_r and E_s.

    Parameters:
    - E_r, E_s: Complex-valued electric field vectors.
    - mu: Phase offset (default is 0).
    - n: Number of phase steps or modulation factor (default is 1).
    - plot: Boolean to indicate if the resulting interferogram should be plotted (default is False).
    - x_size: Number of pixels in the x-axis (default is 1000)
    - y_size: Number of pixels in the y-axis (default is 500)

    Returns:
    - info: List containing [b, m, vartheta, theta, cos_term]
      - b: Baseline intensity
      - m: Modulated intensity amplitude
      - vartheta: Relative phase shift between the fields
      - theta: Phase modulation term
      - cos_term: Cosine modulation term
    """

    # Wavelength of the light source (in meters)
    lambda_ = 532e-9  

    # Wave number (k = 2π/λ)
    k = 2 * np.pi / lambda_  

    # Conversion scales from pixels to meters
    x_scale = lambda_ / x_size  # Pixel size in meters along x-axis
    y_scale = lambda_ / y_size  # Pixel size in meters along y-axis

    # Create physical coordinate grids
    x_pixels = np.arange(x_size)  # X pixel indices
    y_pixels = np.arange(y_size)  # Y pixel indices
    X, Y = np.meshgrid(x_pixels, y_pixels)  # 2D coordinate grid
    X_meters = X * x_scale  # X coordinates in meters
    Y_meters = Y * y_scale  # Y coordinates in meters

    # Generate combined spatial coordinate for phase modulation
    x = X_meters + Y_meters

    # Intensity component calculations
    b = np.linalg.norm(E_r)**2 + np.linalg.norm(E_s)**2  # Baseline intensity
    m = np.abs(np.vdot(E_r, E_s))  # Modulated intensity amplitude

    # Compute the relative phase (vartheta)
    numerator = -np.abs(E_r[1]) * np.abs(E_s[1]) * np.sin(np.angle(E_r[1]) - np.angle(E_s[1]))
    denominator = (np.abs(E_r[0]) * np.abs(E_s[0]) +
                   np.abs(E_r[1]) * np.abs(E_s[1]) * np.cos(np.angle(E_r[1]) - np.angle(E_s[1])))
    vartheta = np.arctan(numerator / denominator)[0]

    # Phase modulation term
    theta = (n / 2) * (mu + k * x - vartheta)

    # Cosine term for interference pattern
    cos_term = np.cos(theta)

    # Final intensity calculation
    I = b + m * cos_term

    # Information array for reference
    info = [b, m, vartheta, E_r,theta, cos_term]

    # Optional plotting of the interferogram
    if plot:
        # Normalize the intensity to a range between 0 and 1
        I_norm = (I - I.min()) / (I.max() - I.min())

        # Apply Gaussian blur to smooth the fringe pattern
        I_blurred = cv2.GaussianBlur(I_norm, (5, 5), 0)

        os.makedirs("interferogram", exist_ok=True)

        # Format the filename with two decimal precision
        filename = f"int_{b:.2f}_{m:.2f}_{vartheta:.2f}.png"

        # Save the image
        imageio.imwrite(os.path.join("interferogram", filename), (I_blurred * 255).astype('uint8'))

        # Display the interferogram
        plt.figure(figsize=(8, 6))
        extent = [X_meters.min(), X_meters.max(), Y_meters.min(), Y_meters.max()]
        plt.imshow(I_blurred, cmap='gray', aspect='auto', extent=extent)
        plt.xlabel("X (m)")
        plt.ylabel("Y (m)")
        plt.title("Interferogram")
        plt.colorbar(label="Intensity")
        plt.show()

    return info

def Es_numeric_recosntruction(info_1, info_2):
    """
    Numerically reconstructs the electric field component Es based on provided information.

    Parameters:
    - info_1 (list): Contains data such as coefficients, electric field values, and other parameters.
    - info_2 (list): Similar to info_1, containing additional data required for reconstruction.

    Returns:
    - np.ndarray: A 2x1 complex array representing the reconstructed Es vector.
    """

    # Extract relevant values from input data
    b_1 = info_1[0]  # First parameter from info_1 (potentially a squared amplitude term)
    m_1 = info_1[1]  # Second parameter from info_1 (potentially a scaling factor)
    
    E_r1 = info_1[3]  # Electric field values from info_1
    E_r2 = info_2[3]  # Electric field values from info_2

    # Calculate Esx and Esy based on extracted parameters
    Esx = np.abs(m_1 / np.abs(E_r1[0, 0]))
    Esy = np.abs(np.sqrt(b_1 - Esx**2 - E_r1[0, 0]**2))

    # Extract reference electric field components from info_2
    Erx = np.abs(E_r2[0, 0])
    Ery = np.abs(E_r2[1, 0])
    vartheta_2 = info_2[2]  # Phase-related parameter from info_2

    # Define symbolic variable for phase difference
    delta_phi_s = sp.Symbol('delta_phi_s', real=True)

    # Expression for tan(vartheta_2) as a function of delta_phi_s
    tan_vartheta_2_expr = (-Ery * Esy * sp.sin(-delta_phi_s)) / (
        Erx * Esx + Ery * Esy * sp.cos(-delta_phi_s)
    )

    # Define the equation to solve
    equation = sp.tan(vartheta_2) - tan_vartheta_2_expr

    # Solve the equation for delta_phi_s
    solution = sp.solve(equation, delta_phi_s)[0]

    # Convert the symbolic solution to a numerical value
    solution_numeric = float(solution.evalf())
    
    # Handle edge case where the solution is very close to zero
    solution_numeric = np.pi if np.isclose(solution_numeric, 0, atol=1e-6) else solution_numeric

    # Compute the reconstructed Es vector
    Es_calculated = np.array([
        [Esx],
        [Esy * (np.cos(solution_numeric) + 1j * np.sin(solution_numeric))]
    ])

    # Clean up numerical artifacts (remove near-zero values)
    Es_calculated.real[np.abs(Es_calculated.real) < 1e-6] = 0
    Es_calculated.imag[np.abs(Es_calculated.imag) < 1e-6] = 0

    return Es_calculated

def jones_matrix(delta, alpha):
    """
    Computes the Jones matrix for a birefringent optical element.

    Parameters:
    - delta : float
        The phase retardation introduced by the birefringent material (in radians).
        This phase shift is the optical path difference between the fast and slow
        axes of the birefringent material.
    
    - alpha : float
        The orientation angle (in radians) of the fast axis with respect to the
        reference axis (horizontal axis in the standard Jones formalism).

    Returns:
    - np.ndarray
        A 2x2 complex-valued numpy array representing the Jones matrix.
        This matrix describes the effect of the birefringent element on the 
        electric field's polarization state.
    """

    # Compute the individual elements of the Jones matrix
    # Diagonal element [0,0] — Describes the effect on the horizontal polarization component
    m_11 = np.cos(alpha) ** 2 + np.exp(-1j * delta) * np.sin(alpha) ** 2
    
    # Off-diagonal elements [0,1] and [1,0] — Represent the coupling between
    # horizontal and vertical polarization components
    m_12 = m_21 = (1 - np.exp(-1j * delta)) * np.cos(alpha) * np.sin(alpha)

    # Diagonal element [1,1] — Describes the effect on the vertical polarization component
    m_22 = np.sin(alpha) ** 2 + np.exp(-1j * delta) * np.cos(alpha) ** 2

    # Return the Jones matrix as a 2x2 complex-valued numpy array
    return np.array([[m_11, m_12], [m_21, m_22]], dtype=np.complex128)

def PSG(alpha_1, alpha_2):
    """
    Generates a Polarization State Generator (PSG) matrix using a Half-Wave Plate (HWP)
    and a Quarter-Wave Plate (QWP).

    Parameters:
    - alpha_1 : float
        The orientation angle (in radians) of the fast axis of the Half-Wave Plate (HWP)
        with respect to the reference axis.
    
    - alpha_2 : float
        The orientation angle (in radians) of the fast axis of the Quarter-Wave Plate (QWP)
        with respect to the reference axis.

    Returns:
    - np.ndarray
        A 2x2 complex-valued numpy array representing the resulting PSG matrix,
        which describes the combined effect of the QWP and HWP on the polarization state.
    """

    # Generate the Jones matrix for the Half-Wave Plate (HWP)
    # A HWP introduces a π phase retardation (180°) between its fast and slow axes
    HWP = jones_matrix(np.pi, alpha_1)

    # Generate the Jones matrix for the Quarter-Wave Plate (QWP)
    # A QWP introduces a π/2 phase retardation (90°) between its fast and slow axes
    QWP = jones_matrix(np.pi / 2, alpha_2)

    # Return the resulting matrix for the combined PSG system
    # The QWP follows the HWP in the optical path, so the matrices are multiplied in this order
    return QWP @ HWP

def PSG_calculator(In, Out, p=False):
    """
    Calculates the optimal angles for a Half-Wave Plate (HWP) and a Quarter-Wave Plate (QWP) 
    to achieve a desired output polarization state.

    Parameters:
    -----------
    In : ndarray
        Input Jones vector representing the initial polarization state.
    Out : ndarray
        Desired output Jones vector representing the target polarization state.
    p : bool, optional
        If True, prints the calculated angles in terms of π radians (default is False).

    Returns:
    --------
    alpha_1 : float
        Optimal angle for the Half-Wave Plate (HWP) in units of π radians.
    alpha_2 : float
        Optimal angle for the Quarter-Wave Plate (QWP) in units of π radians.
    """

    def objective(params):
        """
        Objective function to minimize the difference between the resulting 
        polarization state and the desired output state.

        Parameters:
        -----------
        params : list or tuple
            Contains the two angles: alpha_1 (HWP) and alpha_2 (QWP) in radians.

        Returns:
        --------
        float
            Norm of the difference between the calculated and desired Jones vector.
        """
        alpha_1, alpha_2 = params  # Extract angles from input
        PSG_matrix = PSG(alpha_1, alpha_2)  # Generate the PSG matrix using the given angles
        result = PSG_matrix @ In  # Compute the resulting Jones vector
        return np.linalg.norm(result - Out)  # Minimize the difference between result and target

    # Initial guess for the angles (both set to 0 radians initially)
    initial_guess = [0, 0]

    # Minimize the objective function with bounds to keep angles within [0, 2π]
    result = minimize(objective, initial_guess, bounds=[(0, 2*np.pi), (0, 2*np.pi)])

    # Extract optimized angles and convert to units of π radians for better readability
    alpha_1, alpha_2 = result.x 

    # Optionally print the calculated angles in terms of π for improved clarity
    if p:
        print(f"HWP: {alpha_1/ np.pi:.4f}π")
        print(f"QWP: {alpha_2/ np.pi:.4f}π")
    
    # Return the calculated angles in units of π
    return alpha_1, alpha_2

# Dictionary containing Jones vectors for common polarization states
bases = {
    'H': np.array([[1 + 0j], [0 + 0j]]),            # Horizontal polarization
    'V': np.array([[0 + 0j], [1 + 0j]]),            # Vertical polarization
    'P45': 1/np.sqrt(2) * np.array([[1+0.j], [1+0j]]),      # +45° Linear polarization
    'N45': 1/np.sqrt(2) * np.array([[1+0j], [-1+0j]]),     # -45° Linear polarization
    'L': 1/np.sqrt(2) * np.array([[1+0j], [0 + 1j]]),       # Left circular polarization
    'R': 1/np.sqrt(2) * np.array([[1+0j], [0 -1j]])       # Right circular polarization
}

def field_notation(E, p=False):
    """
    Converts an electric field vector into field notation by extracting the amplitude 
    and phase difference for both polarization components. Also identifies the polarization type.
    
    Parameters:
    - E (np.array): A 2x1 complex-valued array representing the electric field vector.
    - p (bool): If True, prints the identified polarization type. Default is False.

    Returns:
    - np.array: The electric field vector in its original notation (without normalization).
    """

    # Function to identify the polarization type
    def identify_polarization(E_norm):
        for label, base in bases.items():
            if np.allclose(E_norm, base, atol=1e-6):  # Tolerance for numerical precision
                return label
        return "Elliptical polarization"

    # Extract amplitude (magnitude) and phase for the x-component
    E_x = np.abs(E[0, 0])     # Amplitude of E_x
    phi_x = np.angle(E[0, 0]) # Phase of E_x

    # Extract amplitude (magnitude) and phase for the y-component
    E_y = np.abs(E[1, 0])     # Amplitude of E_y
    phi_y = np.angle(E[1, 0]) # Phase of E_y

    # Determine the phase difference
    if E_x < 1e-6 or E_y < 1e-6:  # Handle near-zero amplitudes to avoid errors
        delta_phi = 0
    else:
        delta_phi = phi_y - phi_x

    # Return the vector in its original notation (without normalization)
    E_ = np.array([[E_x + 0.j], [E_y * (np.cos(delta_phi) + 1j * np.sin(delta_phi))]])

    # Display the polarization type if 'p' is True
    if p:
        polarization_type = identify_polarization(E_/np.linalg.norm(E_))
        print(f"Polarization type: {polarization_type}")
    
    # Eliminate small numerical noise in the real and imaginary parts
    E_.real[np.abs(E_.real) < 1e-3] = 0
    E_.imag[np.abs(E_.imag) < 1e-3] = 0

    return E_

def polarization_basis_set(polarization):
    """
    Returns the Jones vector corresponding to a specific polarization state,
    using a standard basis of polarization states.

    Parameters:
    -----------
    polarization : str
        Desired polarization state. Available options are:
        - 'H'   : Horizontal polarization        | [1, 0]ᵀ
        - 'V'   : Vertical polarization          | [0, 1]ᵀ
        - 'P45' : +45° linear polarization       | (1/√2) [1, 1]ᵀ
        - 'N45' : -45° linear polarization       | (1/√2) [1, -1]ᵀ
        - 'L'   : Left circular polarization     | (1/√2) [1, i]ᵀ
        - 'R'   : Right circular polarization    | (1/√2) [1, -i]ᵀ

    Returns:
    --------
    ndarray
        Jones vector representing the desired polarization state in electric field notation.

    Exceptions:
    -----------
    ValueError
        Raised if the `polarization` parameter does not match one of the valid states.
    """

    # Retrieve the corresponding Jones vector for the requested polarization state
    E = bases.get(polarization)
    
    # Error handling for invalid polarization states
    if E is None:
        raise ValueError(f"Error: Polarization state '{polarization}' not recognized.")
    
    # Return the Jones vector in electric field notation
    return E

def initialize_environment(lambda_=532e-9, x_size=1000, y_size=500):
    """
    Initializes the sample environment with defined dimensions and wavelength scaling.
    
    Parameters:
    - lambda_ : float -> Wavelength of the light in meters (default: 532 nm).
    - x_size : int -> Width of the sample grid.
    - y_size : int -> Height of the sample grid.

    Returns:
    - sample : ndarray -> Array containing Jones matrices for each point.
    - sample_image : ndarray -> Intensity map for visualization.
    - X, Y : ndarray -> Coordinate grids for spatial mapping.
    """
    scale = lambda_ / np.array([x_size, y_size])  # Scaling factor based on wavelength
    X, Y = np.meshgrid(np.arange(x_size) * scale[0], np.arange(y_size) * scale[1])
    sample_image = np.zeros((y_size, x_size), dtype=np.uint8)  # Initial sample image (empty)
    sample = np.full((y_size, x_size, 2, 2), np.eye(2, dtype=np.complex128), dtype=np.complex128)  # Jones matrix map
    return sample, sample_image, X, Y

def add_lines(positions, matrices, sample_image, sample, grosor=50):
    """
    Adds linear features with random intensity values to the sample environment.

    Parameters:
    - positions : list -> List of y-coordinates for the lines.
    - matrices : list -> List of Jones matrices corresponding to each line.
    - sample_image : ndarray -> Image array to display the sample.
    - sample : ndarray -> Jones matrix array of the sample.
    - grosor : int -> Thickness of the lines in pixels (default: 50).

    Returns:
    - sample : ndarray -> Updated sample with added lines.
    """
    intensity_values = np.linspace(50, 255, len(positions)).astype(int)
    for y_pos, intensity_value, line_matrix in zip(positions, intensity_values, matrices):
        sample_image[y_pos:y_pos + grosor, :] = intensity_value
        sample[y_pos:y_pos + grosor, :, :] = line_matrix

    plt.imshow(sample_image, cmap='inferno')
    plt.title('Physics representation of the sample')
    plt.xlabel('X (m)')
    plt.ylabel('Y (m)')
    plt.show()

    return sample

def add_circles(positions, matrices, sample_image, sample, diameter_pixels=130):
    """
    Adds circular features with random intensity values to the sample environment.

    Parameters:
    - positions : list -> List of (x, y) coordinates for the circle centers.
    - matrices : list -> List of Jones matrices corresponding to each circle.
    - sample_image : ndarray -> Image array to display the sample.
    - sample : ndarray -> Jones matrix array of the sample.
    - diameter_pixels : int -> Diameter of the circles in pixels (default: 130).

    Returns:
    - sample : ndarray -> Updated sample with added circles.
    """
    intensity_values = np.linspace(50, 255, len(positions)).astype(int)

    for (center_x, center_y), intensity_value, circle_matrix in zip(positions, intensity_values, matrices):
        y, x = np.ogrid[:sample_image.shape[0], :sample_image.shape[1]]
        mask = (x - center_x)**2 + (y - center_y)**2 <= (diameter_pixels // 2) ** 2
        sample_image[mask] = intensity_value
        sample[mask, :, :] = circle_matrix

    plt.imshow(sample_image, cmap='inferno')
    plt.title('Physics representation of the sample')
    plt.xlabel('X (m)')
    plt.ylabel('Y (m)')
    plt.show()

    return sample

def create_vector_matrix(E, shape):
    """
    Creates a 2D array filled with copies of the provided vector E.

    Parameters:
    - E : ndarray -> Input Jones vector.
    - shape : tuple -> Shape of the resulting matrix.

    Returns:
    - E_map : ndarray -> Matrix filled with copies of the input vector.
    """
    
    E_map = np.empty(shape, dtype=object)
    for i in range(shape[0]):
        for j in range(shape[1]):
            E_map[i, j] = E.copy()
    return E_map

def sample_intensity(Er, E_is, sample, X_meters, Y_meters, franjas=40, lambda_=532e-9):
    """
    Calculates the intensity of the interferogram using Jones matrices and field vectors.

    Parameters:
    - Er : ndarray -> Reference electric field Jones vector.
    - E_is : ndarray -> Sample electric field Jones vector.
    - sample : ndarray -> Jones matrix array of the sample.
    - X_meters : ndarray -> X-coordinate grid in meters.
    - Y_meters : ndarray -> Y-coordinate grid in meters.
    - franjas : int -> Fringe density for phase modulation (default: 40).
    - lambda_ : float -> Wavelength of the light in meters (default: 532 nm).

    Returns:
    - List containing:
      - b : ndarray -> Background intensity term.
      - m : ndarray -> Modulation amplitude term.
      - theta : ndarray -> Phase modulation term.
    """
    k = 2 * np.pi / lambda_  # Wave number

    E_is = create_vector_matrix(E_is, sample.shape[:2])
    E_r = create_vector_matrix(Er, sample.shape[:2])
    E_s = np.empty_like(E_is, dtype=object)
    for i in range(sample.shape[0]):
        for j in range(sample.shape[1]):
            E_s[i, j] = sample[i, j] @ E_is[i, j]  # Applying Jones transformation
    A = E_r
    B = E_s

    # Flatten Jones vectors for easier calculations
    E_r = np.stack([[elem.flatten() for elem in row] for row in E_r])
    E_s = np.stack([[elem.flatten() for elem in row] for row in E_s])

    # Intensity calculation
    b = np.sum(np.abs(E_r) ** 2, axis=-1) + np.sum(np.abs(E_s) ** 2, axis=-1)
    #m = np.abs(np.einsum('ijk,ijk->ij', E_r, np.conj(E_s)))
    m = np.abs(np.array([[np.vdot(E_r[i, j], E_s[i, j]) for j in range(E_r.shape[1])] 
                          for i in range(E_r.shape[0])]))

    numerator = -np.abs(E_r[:, :, 1]) * np.abs(E_s[:, :, 1]) * np.sin(np.angle(E_r[:, :, 1]) - np.angle(E_s[:, :, 1]))
    denominator = np.abs(E_r[:, :, 0]) * np.abs(E_s[:, :, 0]) + np.abs(E_r[:, :, 1]) * np.abs(E_s[:, :, 1]) * np.cos(np.angle(E_r[:, :, 1]) - np.angle(E_s[:, :, 1]))
    vartheta = np.arctan2(numerator, denominator)

    n = franjas / 2
    mu = 0  # Global phase shift
    #theta = n * (mu + k * (X_meters + Y_meters) - vartheta)
    theta = n * (mu + k * (X_meters) - vartheta)
    cos_term = np.cos(theta)
    I = b + m * cos_term
    info = [b, m, vartheta, theta, cos_term]

    I_norm = (I - I.min()) / (I.max() - I.min())
    I_blurred = cv2.GaussianBlur(I_norm, (5, 5), 0)

    plt.figure(figsize=(8, 6))
    extent = [X_meters.min(), X_meters.max(), Y_meters.min(), Y_meters.max()]
    plt.imshow(I_blurred, cmap='gray', aspect='auto', extent=extent)
    plt.xlabel("X (m)")
    plt.ylabel("Y (m)")
    plt.title("Interferogram")
    plt.colorbar(label="Intensity")
    plt.show()

    return I,info, A, B

def birefringence_by_minimization(E_in, E_out, p = False):
    """
    Calculates the optimal birefringence parameters (delta_chi and alpha)
    that minimize the difference between a known output electric field (E_out)
    and a generated electric field using a Jones matrix transformation.

    Args:
        E_in (array): Input polarization state vector.
        E_out (array): Desired output polarization state vector.

    Returns:
        tuple: Optimal delta_chi and alpha values in radians.
    """
    # Error function to minimize the difference between calculated and desired outputs
    def error_function(params):
        delta_chi, alpha = params  # Extract parameters
        M = jones_matrix(delta_chi, alpha)  # Jones matrix with given parameters
        result = M @ E_in  # Calculated polarization state
        return np.linalg.norm(result - E_out)  # Norm of the difference as error metric

    # Initial guess for the minimization process (delta_chi = 0, alpha = 0)
    initial_guess = [0, 0]

    # Perform the minimization using the Nelder-Mead method
    result = minimize(error_function, initial_guess, method='Nelder-Mead')

    # Extract optimal parameters
    optimal_delta_chi, optimal_alpha = result.x

    if p:
        
        print(f"χ: {optimal_delta_chi/np.pi:.4f}π")
        print(f"α: {optimal_alpha/np.pi:.4f}π")

    return optimal_delta_chi, optimal_alpha

def determine_A(x_vectors, b_vectors, p=False):
    """
    Determines the matrix A such that A * x = b for given sets of x and b vectors.

    This function computes the matrix A that minimizes the least-squares error 
    in the system of equations using Kronecker products and vectorization.

    Parameters:
    - x_vectors (list of numpy arrays): List of 2x1 column vectors representing the 'x' values.
    - b_vectors (list of numpy arrays): List of 2x1 column vectors representing the 'b' values.
    - p (bool, optional): If True, prints the determined matrix A and the calculated alpha value.

    Returns:
    - A (numpy array): A 2x2 matrix that minimizes the least-squares error.
    - alpha_calculated (float): The calculated alpha value corresponding to the dominant eigenvector's angle.

    Raises:
    - ValueError: If the number of 'x' vectors and 'b' vectors are not equal.
    """

    # Ensure both lists have the same number of vectors
    if len(x_vectors) != len(b_vectors):
        raise ValueError("The lists of vectors must have the same length.")

    # Construct matrix M by stacking Kronecker products of identity matrix with transposed 'x' vectors
    M = np.vstack([np.kron(np.eye(2), xi.T) for xi in x_vectors])

    # Stack all 'b' vectors into a single column matrix
    B = np.vstack(b_vectors)

    # Solve the least-squares problem to determine the vectorized form of matrix A
    A_vector, residuals, rank, s = np.linalg.lstsq(M, B, rcond=None)

    # Reshape the resulting vector into a 2x2 matrix
    A = A_vector.reshape(2, 2)

    # Eigenvalue and eigenvector calculation (Principal Component Analysis)
    eigenvalues, eigenvectors = eig(A)

    # Determine alpha (angle) from the dominant eigenvector
    alpha_calculated = np.abs(np.arctan2(np.real(eigenvectors[1, 0]), np.real(eigenvectors[0, 0])))

    if p:
        # Display results if 'p' is True
        print("Determined matrix A:")
        print(A, "\n")
        print(f"α (dominant direction): {alpha_calculated / np.pi:.4f}π\n")

    return A, alpha_calculated

def calculate_chi(alpha, E_is, E_s, p=False):
    """
    Calculates the phase shift parameter (chi) for a birefringent optical system using minimization.
    
    Parameters:
    - alpha (float): The orientation angle of the birefringent material's fast axis (in radians).
    - E_is (array): The input Jones vector representing the initial polarization state.
    - E_s (array): The output Jones vector representing the modified polarization state.
    - p (bool): If True, prints the calculated phase shift in terms of π.

    Returns:
    - float: The calculated phase shift (chi) in radians if a solution is found.
    - str: A message indicating no solution was found if calculations are inconsistent.
    """

    # Extract magnitudes and phases of the input Jones vector (E_is)
    A_isx, A_isy = sp.Abs(E_is[0, 0]), sp.Abs(E_is[1, 0])  # Magnitudes
    delta_phi_is = sp.arg(E_is[1, 0])                        # Phase of the second component

    # Extract magnitudes and phases of the output Jones vector (E_s)
    A_sx, phi_sx = sp.Abs(E_s[0, 0]), sp.arg(E_s[0, 0])    # Magnitude and phase of Ex (output)
    A_sy, phi_sy = sp.Abs(E_s[1, 0]), sp.arg(E_s[1, 0])    # Magnitude and phase of Ey (output)

    # Convert symbolic expressions to numerical functions using lambdify
    A_isx_func = sp.lambdify((), A_isx, 'numpy')
    A_isy_func = sp.lambdify((), A_isy, 'numpy')
    delta_phi_is_func = sp.lambdify((), delta_phi_is, 'numpy')
    A_sx_func = sp.lambdify((), A_sx, 'numpy')
    phi_sx_func = sp.lambdify((), phi_sx, 'numpy')
    A_sy_func = sp.lambdify((), A_sy, 'numpy')
    phi_sy_func = sp.lambdify((), phi_sy, 'numpy')

    def error_function(chi):
        term1 = np.abs(A_sx_func() * np.exp(1j * phi_sx_func()) -
                       ((np.cos(alpha)**2 + np.exp(-1j * chi) * np.sin(alpha)**2) * A_isx_func() +
                        ((1 - np.exp(-1j * chi)) * np.cos(alpha) * np.sin(alpha)) * A_isy_func() * np.exp(1j * delta_phi_is_func())))

        term2 = np.abs(A_sy_func() * np.exp(1j * phi_sy_func()) -
                       (((1 - np.exp(-1j * chi)) * np.cos(alpha) * np.sin(alpha)) * A_isx_func() +
                        (np.sin(alpha)**2 + np.exp(-1j * chi) * np.cos(alpha)**2) * A_isy_func() * np.exp(1j * delta_phi_is_func())))

        return np.abs(term1) + np.abs(term2)

    # Minimize the error function with improved settings
    result = minimize(error_function, x0=np.pi/2, bounds=[(0, 2 * np.pi)], tol=1e-6)

    if result.success:
        chi_calculated = result.x[0]
        if p:
            print(f"Calculated value of Δχ: {chi_calculated / np.pi:.4f}π")
        return chi_calculated
    else:
        return np.pi/2

def calculate_phase_shift(I1, I2, X):
    # Center the signals by subtracting the mean
    I1_centered = I1 - np.mean(I1)
    I2_centered = I2 - np.mean(I2)
    
    # Interpolation to improve resolution
    x_interpolated = np.linspace(X.min(), X.max(), 10 * len(X))
    interp_I1 = interp1d(X, I1_centered, kind='cubic')
    interp_I2 = interp1d(X, I2_centered, kind='cubic')

    # Generate interpolated signals
    I1_interp = interp_I1(x_interpolated)
    I2_interp = interp_I2(x_interpolated)

    # Perform FFT on each interpolated signal
    fft_I1 = fft(I1_interp)
    fft_I2 = fft(I2_interp)

    # Identify the dominant frequency
    frequencies = fftfreq(len(x_interpolated), x_interpolated[1] - x_interpolated[0])
    dominant_freq_index = np.argmax(np.abs(fft_I1))  # Index of the peak in FFT

    # Extract phase at the dominant frequency
    phase_I1 = np.angle(fft_I1[dominant_freq_index])
    phase_I2 = np.angle(fft_I2[dominant_freq_index])

    # Compute the phase shift (in radians)
    delta_phi = phase_I2 - phase_I1

    # Conversion of phase shift to distance (in meters)
    # Wavelength is defined as 532 nm (green laser typical value)
    wavelength = 532e-9
    delta_x = delta_phi / (2 * np.pi) * wavelength     # Phase shift converted to meters
    
    # Return the calculated phase shift (uncomment delta_x if distance is preferred)
    # return delta_x
    return delta_phi

