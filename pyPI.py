import sympy as sp
import matplotlib.pyplot as plt
import cv2
import numpy as np
from scipy.optimize import minimize


def symbolic_intensity(values=None):
    """
    Calculates the intensity pattern resulting from the interaction of polarized light
    with a birefringent material, modeled using Jones matrices and phase modulation.

    Parameters:
    -----------
    values : dict, optional
        A dictionary containing specific numerical values for the symbolic variables.
        If provided, the resulting intensity will be evaluated numerically.

    Returns:
    --------
    I : sympy expression or numerical value
        The calculated intensity as a symbolic expression or evaluated result
        if `values` is provided.
    """

    # Define symbolic variables for phase angles, spatial modulation, and amplitudes
    alpha, chi, mu, k, x, phi_is, phi_r = sp.symbols('alpha chi mu k x phi_is phi_r', real=True)
    A_isx, A_isy, A_rx, A_ry = sp.symbols('A_isx A_isy A_rx A_ry', real=True)

    # Define the reference electric field vector A_r
    E_r = sp.Matrix([[A_rx], [A_ry * sp.exp(1j * phi_r)]])

    # Waveplate (birefringent) matrix coefficients (Jones formalism)
    S_xx = sp.cos(alpha)**2 + sp.exp(-1j * chi) * sp.sin(alpha)**2
    S_xy = (1 - sp.exp(-1j * chi)) * sp.cos(alpha) * sp.sin(alpha)
    S_yx = S_xy
    S_yy = sp.sin(alpha)**2 + sp.exp(-1j * chi) * sp.cos(alpha)**2

    # Transformation of the input electric field vector E_is through the waveplate
    E_sx = S_xx * A_isx + S_xy * A_isy * sp.exp(1j * phi_is)
    E_sy = S_yx * A_isx + S_yy * A_isy * sp.exp(1j * phi_is)
    E_s = sp.Matrix([[E_sx], [E_sy]])

    # Intensity calculation components
    # Background 'b' is the sum of the squared norms (amplitudes) of the reference and sample vectors
    b = E_r.norm()**2 + E_s.norm()**2
    
    # Modulation 'm' is the magnitude of the dot product between the reference and transformed sample vectors
    m = sp.Abs(E_r.dot(E_s))

    # Calculation of the relative phase shift (vartheta)
    numerator = -sp.Abs(E_r[1, 0]) * sp.Abs(E_s[1]) * sp.sin(sp.arg(E_r[1, 0]) - sp.arg(E_s[1]))
    denominator = sp.Abs(E_r[0, 0]) * sp.Abs(E_s[0]) + sp.Abs(E_r[1, 0]) * sp.Abs(E_s[1]) * sp.cos(sp.arg(E_r[1, 0]) - sp.arg(E_s[1]))
    vartheta = sp.atan(numerator / denominator)

    # Phase modulation incorporating spatial modulation (kx) and global phase shift (mu)
    theta = (mu + k * x - vartheta)
    cos_term = sp.cos(theta)

    # Final intensity expression combining all calculated terms
    I = b + m * cos_term

    # Substitute numerical values if provided
    if values:
        I = I.subs(values).evalf()

    return I

def numeric_intensity(E_r, E_s, mu=0, x_size = 1000, y_size = 500, n=1, plot=False):
    """
    Computes the numerical intensity distribution for an interferogram 
    generated by two electric field vectors E_r and E_s.

    Parameters:
    - E_r, E_s: Complex-valued electric field vectors.
    - mu: Phase offset (default is 0).
    - n: Number of phase steps or modulation factor (default is 1).
    - plot: Boolean to indicate if the resulting interferogram should be plotted (default is False).
    - x_size: Number of pixels in the x-axis (default is 1000)
    - y_size: Number of pixels in the y-axis (default is 500)

    Returns:
    - info: List containing [b, m, vartheta, theta, cos_term]
      - b: Baseline intensity
      - m: Modulated intensity amplitude
      - vartheta: Relative phase shift between the fields
      - theta: Phase modulation term
      - cos_term: Cosine modulation term
    """

    # Wavelength of the light source (in meters)
    lambda_ = 532e-9  

    # Wave number (k = 2π/λ)
    k = 2 * np.pi / lambda_  

    # Conversion scales from pixels to meters
    x_scale = lambda_ / x_size  # Pixel size in meters along x-axis
    y_scale = lambda_ / y_size  # Pixel size in meters along y-axis

    # Create physical coordinate grids
    x_pixels = np.arange(x_size)  # X pixel indices
    y_pixels = np.arange(y_size)  # Y pixel indices
    X, Y = np.meshgrid(x_pixels, y_pixels)  # 2D coordinate grid
    X_meters = X * x_scale  # X coordinates in meters
    Y_meters = Y * y_scale  # Y coordinates in meters

    # Generate combined spatial coordinate for phase modulation
    x = X_meters + Y_meters

    # Intensity component calculations
    b = np.linalg.norm(E_r)**2 + np.linalg.norm(E_s)**2  # Baseline intensity
    m = np.abs(np.vdot(E_r, E_s))  # Modulated intensity amplitude

    # Compute the relative phase (vartheta)
    numerator = -np.abs(E_r[1]) * np.abs(E_s[1]) * np.sin(np.angle(E_r[1]) - np.angle(E_s[1]))
    denominator = (np.abs(E_r[0]) * np.abs(E_s[0]) +
                   np.abs(E_r[1]) * np.abs(E_s[1]) * np.cos(np.angle(E_r[1]) - np.angle(E_s[1])))
    vartheta = np.arctan(numerator / denominator)[0]

    # Phase modulation term
    theta = (n / 2) * (mu + k * x - vartheta)

    # Cosine term for interference pattern
    cos_term = np.cos(theta)

    # Final intensity calculation
    I = b + m * cos_term

    # Information array for reference
    info = [b, m, vartheta, theta, cos_term]

    # Optional plotting of the interferogram
    if plot:
        # Normalize the intensity to a range between 0 and 1
        I_norm = (I - I.min()) / (I.max() - I.min())

        # Apply Gaussian blur to smooth the fringe pattern
        I_blurred = cv2.GaussianBlur(I_norm, (5, 5), 0)

        # Display the interferogram
        plt.figure(figsize=(8, 6))
        extent = [X_meters.min(), X_meters.max(), Y_meters.min(), Y_meters.max()]
        plt.imshow(I_blurred, cmap='gray', aspect='auto', extent=extent)
        plt.xlabel("X (m)")
        plt.ylabel("Y (m)")
        plt.title("Interferogram")
        plt.colorbar(label="Intensity")
        plt.show()

    return info

def jones_matrix(delta, alpha):
    """
    Computes the Jones matrix for a birefringent optical element.

    Parameters:
    - delta : float
        The phase retardation introduced by the birefringent material (in radians).
        This phase shift is the optical path difference between the fast and slow
        axes of the birefringent material.
    
    - alpha : float
        The orientation angle (in radians) of the fast axis with respect to the
        reference axis (horizontal axis in the standard Jones formalism).

    Returns:
    - np.ndarray
        A 2x2 complex-valued numpy array representing the Jones matrix.
        This matrix describes the effect of the birefringent element on the 
        electric field's polarization state.
    """

    # Compute the individual elements of the Jones matrix
    # Diagonal element [0,0] — Describes the effect on the horizontal polarization component
    m_11 = np.cos(alpha) ** 2 + np.exp(-1j * delta) * np.sin(alpha) ** 2
    
    # Off-diagonal elements [0,1] and [1,0] — Represent the coupling between
    # horizontal and vertical polarization components
    m_12 = m_21 = (1 - np.exp(-1j * delta)) * np.cos(alpha) * np.sin(alpha)

    # Diagonal element [1,1] — Describes the effect on the vertical polarization component
    m_22 = np.sin(alpha) ** 2 + np.exp(-1j * delta) * np.cos(alpha) ** 2

    # Return the Jones matrix as a 2x2 complex-valued numpy array
    return np.array([[m_11, m_12], [m_21, m_22]], dtype=np.complex128)

def PSG(alpha_1, alpha_2):
    """
    Generates a Polarization State Generator (PSG) matrix using a Half-Wave Plate (HWP)
    and a Quarter-Wave Plate (QWP).

    Parameters:
    - alpha_1 : float
        The orientation angle (in radians) of the fast axis of the Half-Wave Plate (HWP)
        with respect to the reference axis.
    
    - alpha_2 : float
        The orientation angle (in radians) of the fast axis of the Quarter-Wave Plate (QWP)
        with respect to the reference axis.

    Returns:
    - np.ndarray
        A 2x2 complex-valued numpy array representing the resulting PSG matrix,
        which describes the combined effect of the QWP and HWP on the polarization state.
    """

    # Generate the Jones matrix for the Half-Wave Plate (HWP)
    # A HWP introduces a π phase retardation (180°) between its fast and slow axes
    HWP = jones_matrix(np.pi, alpha_1)

    # Generate the Jones matrix for the Quarter-Wave Plate (QWP)
    # A QWP introduces a π/2 phase retardation (90°) between its fast and slow axes
    QWP = jones_matrix(np.pi / 2, alpha_2)

    # Return the resulting matrix for the combined PSG system
    # The QWP follows the HWP in the optical path, so the matrices are multiplied in this order
    return QWP @ HWP

import numpy as np
from scipy.optimize import minimize

def PSG_calculator(In, Out, p=False):
    """
    Calculates the optimal angles for a Half-Wave Plate (HWP) and a Quarter-Wave Plate (QWP) 
    to achieve a desired output polarization state.

    Parameters:
    -----------
    In : ndarray
        Input Jones vector representing the initial polarization state.
    Out : ndarray
        Desired output Jones vector representing the target polarization state.
    p : bool, optional
        If True, prints the calculated angles in terms of π radians (default is False).

    Returns:
    --------
    alpha_1 : float
        Optimal angle for the Half-Wave Plate (HWP) in units of π radians.
    alpha_2 : float
        Optimal angle for the Quarter-Wave Plate (QWP) in units of π radians.
    """

    def objective(params):
        """
        Objective function to minimize the difference between the resulting 
        polarization state and the desired output state.

        Parameters:
        -----------
        params : list or tuple
            Contains the two angles: alpha_1 (HWP) and alpha_2 (QWP) in radians.

        Returns:
        --------
        float
            Norm of the difference between the calculated and desired Jones vector.
        """
        alpha_1, alpha_2 = params  # Extract angles from input
        PSG_matrix = PSG(alpha_1, alpha_2)  # Generate the PSG matrix using the given angles
        result = PSG_matrix @ In  # Compute the resulting Jones vector
        return np.linalg.norm(result - Out)  # Minimize the difference between result and target

    # Initial guess for the angles (both set to 0 radians initially)
    initial_guess = [0, 0]

    # Minimize the objective function with bounds to keep angles within [0, 2π]
    result = minimize(objective, initial_guess, bounds=[(0, 2*np.pi), (0, 2*np.pi)])

    # Extract optimized angles and convert to units of π radians for better readability
    alpha_1, alpha_2 = result.x / np.pi

    # Optionally print the calculated angles in terms of π for improved clarity
    if p:
        print(f"HWP: alpha_1 = {alpha_1:.4f}π")
        print(f"QWP: alpha_2 = {alpha_2:.4f}π")
    
    # Return the calculated angles in units of π
    return alpha_1, alpha_2


def field_notation(E, p=False):
    """
    Converts an electric field vector into field notation, extracting amplitude 
    and phase information for both polarization components.

    Parameters:
    - E : np.ndarray
        A 2x1 complex-valued array representing the electric field vector.
        E[0, 0] corresponds to the x-polarization component.
        E[1, 0] corresponds to the y-polarization component.

    - p : bool, optional (default = False)
        If True, prints the amplitude of both components and the relative phase
        difference in terms of π.

    Returns:
    - np.ndarray
        A 2x1 complex-valued array in field notation form:
        [[E_x], [E_y * exp(i * delta_phi)]]
        Where:
        - E_x and E_y are the magnitudes (amplitudes) of the field components.
        - delta_phi is the phase difference between the y and x components.
    """

    # Extract the amplitude (magnitude) and phase of the x-component
    E_x = np.round(np.abs(E[0, 0]), 5)    # Magnitude of E_x
    phi_x = np.round(np.angle(E[0, 0]), 5) # Phase of E_x

    # Extract the amplitude (magnitude) and phase of the y-component
    E_y = np.round(np.abs(E[1, 0]), 5)    # Magnitude of E_y
    phi_y = np.round(np.angle(E[1, 0]), 5) # Phase of E_y

    # Compute the relative phase difference (delta_phi)
    delta_phi = np.abs(np.round(phi_y - phi_x, 5))

    # If the x-component is zero, set delta_phi to zero (prevents undefined phase difference)
    if E_x == 0 or E_y == 0:
        delta_phi = 0

    # Print values if 'p' is True
    if p:
        print(E_x)                        # Prints x-component amplitude
        print(E_y)                        # Prints y-component amplitude
        print(f"{np.round(delta_phi / np.pi, 5)}π")    # Prints phase difference in terms of π
        print()                           # Prints newline for readability

    # Return the field notation in the desired format
    return np.array([[E_x], [E_y * np.exp(1j * delta_phi)]])

import numpy as np

def polarization_basis_set(polarization):
    """
    Devuelve el vector de Jones correspondiente a un estado de polarización específico,
    utilizando una base estándar de estados de polarización.

    Parámetros:
    -----------
    polarization : str
        Estado de polarización deseado. Las opciones disponibles son:
        - 'H'   : Polarización horizontal | [1, 0]ᵀ
        - 'V'   : Polarización vertical   | [0, 1]ᵀ
        - 'P45' : Polarización a +45°     | (1/√2) [1, 1]ᵀ
        - 'N45' : Polarización a -45°     | (1/√2) [1, -1]ᵀ
        - 'L'   : Polarización circular izquierda | (1/√2) [1, i]ᵀ
        - 'R'   : Polarización circular derecha    | (1/√2) [1, -i]ᵀ

    Retorna:
    --------
    ndarray
        Vector de Jones que representa el estado de polarización deseado en la notación de campo eléctrico.

    Excepciones:
    ------------
    ValueError
        Se genera si el parámetro `polarization` no coincide con uno de los estados válidos.
    """

    # Diccionario con los vectores de Jones para cada estado de polarización
    bases = {
        'H': np.array([[1], [0]]),            # Horizontal
        'V': np.array([[0], [1]]),            # Vertical
        'P45': 1/np.sqrt(2) * np.array([[1], [1]]),      # +45° Lineal
        'N45': 1/np.sqrt(2) * np.array([[1], [-1]]),     # -45° Lineal
        'L': 1/np.sqrt(2) * np.array([[1], [1j]]),       # Circular izquierda
        'R': 1/np.sqrt(2) * np.array([[1], [-1j]])       # Circular derecha
    }

    # Obtener el vector de Jones correspondiente al estado solicitado
    E = bases.get(polarization)
    
    # Manejo de errores si el estado de polarización no es válido
    if E is None:
        raise ValueError(f"Error: Polarization state '{polarization}' not recognized.")
    
    # Retornar el vector en notación de campo eléctrico
    return E

import numpy as np
import cv2
import matplotlib.pyplot as plt

def initialize_environment(lambda_=532e-9, x_size=1000, y_size=500):
    """
    Initializes the sample environment with defined dimensions and wavelength scaling.
    
    Parameters:
    - lambda_ : float -> Wavelength of the light in meters (default: 532 nm).
    - x_size : int -> Width of the sample grid.
    - y_size : int -> Height of the sample grid.

    Returns:
    - sample : ndarray -> Array containing Jones matrices for each point.
    - sample_image : ndarray -> Intensity map for visualization.
    - X, Y : ndarray -> Coordinate grids for spatial mapping.
    """
    scale = lambda_ / np.array([x_size, y_size])  # Scaling factor based on wavelength
    X, Y = np.meshgrid(np.arange(x_size) * scale[0], np.arange(y_size) * scale[1])
    sample_image = np.zeros((y_size, x_size), dtype=np.uint8)  # Initial sample image (empty)
    sample = np.full((y_size, x_size, 2, 2), np.eye(2, dtype=np.complex128), dtype=np.complex128)  # Jones matrix map
    return sample, sample_image, X, Y

def add_lines(positions, matrices, sample_image, sample, grosor=50):
    """
    Adds linear features with random intensity values to the sample environment.

    Parameters:
    - positions : list -> List of y-coordinates for the lines.
    - matrices : list -> List of Jones matrices corresponding to each line.
    - sample_image : ndarray -> Image array to display the sample.
    - sample : ndarray -> Jones matrix array of the sample.
    - grosor : int -> Thickness of the lines in pixels (default: 50).

    Returns:
    - sample : ndarray -> Updated sample with added lines.
    """
    intensity_values = np.random.randint(50, 256, size=len(positions))
    for y_pos, intensity_value, line_matrix in zip(positions, intensity_values, matrices):
        sample_image[y_pos:y_pos + grosor, :] = intensity_value
        sample[y_pos:y_pos + grosor, :, :] = line_matrix

    plt.imshow(sample_image, cmap='inferno')
    plt.title('Physics representation of the sample')
    plt.xlabel('X (m)')
    plt.ylabel('Y (m)')
    plt.show()

    return sample

def add_circles(positions, matrices, sample_image, sample, diameter_pixels=130):
    """
    Adds circular features with random intensity values to the sample environment.

    Parameters:
    - positions : list -> List of (x, y) coordinates for the circle centers.
    - matrices : list -> List of Jones matrices corresponding to each circle.
    - sample_image : ndarray -> Image array to display the sample.
    - sample : ndarray -> Jones matrix array of the sample.
    - diameter_pixels : int -> Diameter of the circles in pixels (default: 130).

    Returns:
    - sample : ndarray -> Updated sample with added circles.
    """
    intensity_values = np.random.randint(50, 256, size=len(positions))

    for (center_x, center_y), intensity_value, circle_matrix in zip(positions, intensity_values, matrices):
        y, x = np.ogrid[:sample_image.shape[0], :sample_image.shape[1]]
        mask = (x - center_x)**2 + (y - center_y)**2 <= (diameter_pixels // 2) ** 2
        sample_image[mask] = intensity_value
        sample[mask, :, :] = circle_matrix

    plt.imshow(sample_image, cmap='inferno')
    plt.title('Physics representation of the sample')
    plt.xlabel('X (m)')
    plt.ylabel('Y (m)')
    plt.show()

    return sample

def create_vector_matrix(E, shape):
    """
    Creates a 2D array filled with copies of the provided vector E.

    Parameters:
    - E : ndarray -> Input Jones vector.
    - shape : tuple -> Shape of the resulting matrix.

    Returns:
    - E_map : ndarray -> Matrix filled with copies of the input vector.
    """
    E_map = np.empty(shape, dtype=object)
    for i in range(shape[0]):
        for j in range(shape[1]):
            E_map[i, j] = E.copy()
    return E_map

def sample_intensity(Er, E_is, sample, X_meters, Y_meters, franjas=40, lambda_=532e-9):
    """
    Calculates the intensity of the interferogram using Jones matrices and field vectors.

    Parameters:
    - Er : ndarray -> Reference electric field Jones vector.
    - E_is : ndarray -> Sample electric field Jones vector.
    - sample : ndarray -> Jones matrix array of the sample.
    - X_meters : ndarray -> X-coordinate grid in meters.
    - Y_meters : ndarray -> Y-coordinate grid in meters.
    - franjas : int -> Fringe density for phase modulation (default: 40).
    - lambda_ : float -> Wavelength of the light in meters (default: 532 nm).

    Returns:
    - List containing:
      - b : ndarray -> Background intensity term.
      - m : ndarray -> Modulation amplitude term.
      - theta : ndarray -> Phase modulation term.
    """
    k = 2 * np.pi / lambda_  # Wave number

    E_is = create_vector_matrix(E_is, sample.shape[:2])
    E_s = np.empty_like(E_is, dtype=object)
    for i in range(sample.shape[0]):
        for j in range(sample.shape[1]):
            E_s[i, j] = sample[i, j] @ E_is[i, j]  # Applying Jones transformation

    E_r = create_vector_matrix(Er, sample.shape[:2])

    # Flatten Jones vectors for easier calculations
    E_r = np.stack([[elem.flatten() for elem in row] for row in E_r])
    E_s = np.stack([[elem.flatten() for elem in row] for row in E_s])

    # Intensity calculation
    b = np.sum(np.abs(E_r) ** 2, axis=-1) + np.sum(np.abs(E_s) ** 2, axis=-1)
    m = np.abs(np.array([[np.vdot(E_r[i, j], E_s[i, j]) for j in range(E_r.shape[1])] 
                          for i in range(E_r.shape[0])]))

    numerator = -np.abs(E_r[:, :, 1]) * np.abs(E_s[:, :, 1]) * np.sin(np.angle(E_r[:, :, 1]) - np.angle(E_s[:, :, 1]))
    denominator = np.abs(E_r[:, :, 0]) * np.abs(E_s[:, :, 0]) + np.abs(E_r[:, :, 1]) * np.abs(E_s[:, :, 1]) * np.cos(np.angle(E_r[:, :, 1]) - np.angle(E_s[:, :, 1]))
    vartheta = np.arctan2(numerator, denominator)

    n = franjas / 2
    mu = 0  # Global phase shift
    theta = n * (mu + k * (X_meters + Y_meters) - vartheta)
    I = b + m * np.cos(theta)

    I_norm = (I - I.min()) / (I.max() - I.min())
    I_blurred = cv2.GaussianBlur(I_norm, (5, 5), 0)

    plt.figure(figsize=(8, 6))
    extent = [X_meters.min(), X_meters.max(), Y_meters.min(), Y_meters.max()]
    plt.imshow(I_blurred, cmap='gray', aspect='auto', extent=extent)
    plt.xlabel("X (m)")
    plt.ylabel("Y (m)")
    plt.title("Interferogram")
    plt.colorbar(label="Intensity")
    plt.show()

    return I_norm